# Oralce 11g 快速添加带默认值的非空约束特性可能引起的 Bug



## 前置知识点

1. 非空列可以定义空默认值
> Oracle 允许定义默认值为空字符串的非空约束，即“default '' not null”，等价于 null
2. 11g 快速添加带默认值非空
> 11g 为加快增加带默认值的非空约束，不再将默认值存储于已存在的记录，而是存储于 sys.ecol$ 中

## 问题的产生

基于前面两点，如果在 11g 中增加一个默认值为空字符串的非空约束列，那么在对该列进行查询过滤和相关空值函数处理时，将呈现出不一致的行为。

问题的根源在于，虽然添加列后也不能向该列插入空值，但是之前已存在的记录中，由于新特性，该列的值为空。即表中存在“不正确”的数据。

导致的结果是，使用“is null”条件过滤该列，总是返回空结果集，而使用“is not null”条件却能返回该列为空的“不正确”数据；另一方面，与空值判断相关的函数，比如：dump、nvl，其行为仍是正确的。

## 问题分析

首先，要明确的是添加列前已存在的记录，在添加列后，该列中数据的确是空。

因此，函数表现出的行为是正确的。

再看查询条件的问题。

我们查看执行计划，会发现“is null”查询的执行计划中有一个过滤器（Filter），其内容是“NULL IS NOT NULL”；而“is not null”查询的执行计划中却没有非空过滤器。

```
set autot on exp  -- 打开执行计划
```

引起反常的执行计划的原因是，CBO（Cost-Based Optimization，基于成本的优化）。

“is null”查询时，由于该列上有非空约束，所以 Oracle 认为该条件是违反约束的，所以自动添加了一个“NULL IS NOT NULL”的恒假过滤器，致使不会执行该查询直接返回空结果集。

“is not null”查询时，也由于非空约束，Oracle 认为该条件恒真，因此是冗余的，因此优化掉了该非空过滤条件，致使查询退化为了全表扫描（这里没有加其他过滤条件）。

至此，问题分析完毕。

## 最佳实践

在 11g 应该禁止添加默认值为空的非空约束列。

